{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Date Range Popover","text":"<p><code>date_range_popover</code> packages a production-ready PyQt6 date &amp; range picker that drops cleanly into data-entry tools and internal desktop apps.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>pip install valgo-date-range-popover\npython -m examples.basic_popover_demo\n</code></pre> <p>To embed the widget in your application:</p> <pre><code>from PyQt6.QtWidgets import QApplication\nfrom date_range_popover import DatePickerConfig, DateRangePopover, PickerMode\n\napp = QApplication([])\nconfig = DatePickerConfig(mode=PickerMode.DATE)\npopover = DateRangePopover(config=config)\npopover.show()\napp.exec()\n</code></pre>"},{"location":"#documentation-map","title":"Documentation Map","text":"<ul> <li>Architecture explains the state manager, coordination   layer, and theming system.</li> <li>Embedding Guide shows how to configure the picker and wire it   into host applications.</li> <li>Public Surface enumerates the officially supported API.</li> <li>Python Reference is generated from docstrings using   <code>mkdocstrings</code>.</li> </ul>"},{"location":"#support-matrix","title":"Support Matrix","text":"<ul> <li>Python 3.10 \u2013 3.13</li> <li>PyQt6 6.5 \u2013 6.7</li> <li>Linux, macOS, and Windows targets (Qt handles windowing differences).</li> </ul> <p>Report issues or start discussions on GitHub.</p>"},{"location":"architecture/","title":"Architecture &amp; Design Notes","text":"<p>The picker separates pure state management from Qt widgets so the core logic can be tested and reused independent of the GUI layer.</p>"},{"location":"architecture/#high-level-flow","title":"High-Level Flow","text":"<ol> <li>State Manager (<code>DatePickerStateManager</code>) keeps the canonical selection    state, clamps values to <code>[min_date, max_date]</code>, and exposes granular signals.</li> <li>Coordinator listens to state changes and updates UI components (button    strip, calendar, date/time inputs).</li> <li>Widgets render the state and forward user input back through the    coordinator.</li> </ol> <p>This creates a predictable loop:</p> <pre><code>User input -&gt; Coordinator -&gt; State manager -&gt; Signals -&gt; Widgets\n</code></pre>"},{"location":"architecture/#pure-logic-vs-gui-modules","title":"Pure Logic vs GUI Modules","text":"<ul> <li>Pure Python: <code>date_range_popover.core.state_logic</code>, <code>date_range_popover.utils.*</code>,   and validation helpers. These modules never import Qt widgets and can be unit   tested in headless environments.</li> <li>GUI Modules: Components under <code>date_range_popover.components.*</code>,   animators, and the popover widget. They depend on PyQt6 for rendering.</li> </ul> <p>Keeping logic isolated enables property-based tests (see <code>tests/properties/test_invariants.py</code>) and makes it feasible to drive a future non-Qt frontend from the same state/validation layer.</p>"},{"location":"architecture/#theming-styling","title":"Theming &amp; Styling","text":"<p><code>Theme</code> combines a <code>ColorPalette</code> and <code>LayoutConfig</code>. The palette validates every hex string, while the layout clamps numeric values via <code>validate_dimension</code>. <code>StyleRegistry</code> converts those tokens into widget-specific style objects, and <code>StyleManager</code> applies them to widgets at runtime. Registering a new palette or layout does not require touching widget code.</p>"},{"location":"architecture/#picker-modes","title":"Picker Modes","text":"<p><code>PickerMode</code> currently defines two values:</p> <ul> <li><code>DATE</code> \u2013 single-date selection with a compact layout.</li> <li><code>CUSTOM_RANGE</code> \u2013 dual-date inputs plus additional actions.</li> </ul> <p>Switching modes triggers a sliding indicator animation (<code>SlideAnimator</code>) and resizes the popover to pre-defined heights, but the state manager retains the underlying selection so users can bounce between modes without losing progress.</p>"},{"location":"architecture/#signals-threading","title":"Signals &amp; Threading","text":"<p>All signals fire on the Qt GUI thread. The library does not spawn background threads, so embedder code can safely mutate UI state inside signal handlers as long as it adheres to Qt's threading rules.</p>"},{"location":"architecture/#extension-points","title":"Extension Points","text":"<p>Upcoming documentation in <code>docs/extending.md</code> will cover:</p> <ul> <li>Registering custom themes and palettes.</li> <li>Hooking into range selection via callbacks in addition to Qt signals.</li> <li>Replacing calendar renderers while reusing the state manager.</li> </ul> <p>If you plan to depend on internals, prefer filing an issue so we can discuss promoting new hooks to the supported surface.</p>"},{"location":"embedding/","title":"Embedding Guide","text":""},{"location":"embedding/#embedding-input-sanitisation","title":"Embedding &amp; Input Sanitisation","text":"<p><code>DateRangePopover</code> is designed to live inside larger desktop apps, which often means configuration data originates outside of your direct control (settings files, remote APIs, user-editable forms, etc.). This guide explains how to safely bridge that external input into the picker.</p>"},{"location":"embedding/#1-normalise-external-data","title":"1. Normalise external data","text":"<p>Always convert raw inputs into concrete Python types before building a <code>DatePickerConfig</code>. For example, parse ISO date strings into <code>QDate</code> objects and clamp integers to sensible ranges.</p> <pre><code>from PyQt6.QtCore import QDate\n\ndef parse_iso_date(value: str | None) -&gt; QDate | None:\n    if not value:\n        return None\n    candidate = QDate.fromString(value, \"yyyy-MM-dd\")\n    return candidate if candidate.isValid() else None\n</code></pre>"},{"location":"embedding/#2-reuse-the-built-in-validators","title":"2. Reuse the built-in validators","text":"<p>After you have provisional types, call the validation helpers shipped with the library to double check everything. They raise descriptive exceptions you can surface to users or logs.</p> <pre><code>from date_range_popover.validation import validate_date_range, validate_qdate\n\ndef sanitise_payload(payload: dict) -&gt; tuple[QDate | None, QDate | None]:\n    start = parse_iso_date(payload.get(\"start\"))\n    end = parse_iso_date(payload.get(\"end\"))\n    return validate_date_range(start, end, field_name=\"user_payload\")\n\ndef sanitise_anchor(date_str: str | None) -&gt; QDate | None:\n    return validate_qdate(parse_iso_date(date_str), field_name=\"anchor\", allow_none=True)\n</code></pre>"},{"location":"embedding/#3-construct-datepickerconfig-inside-try-except","title":"3. Construct <code>DatePickerConfig</code> inside <code>try</code> / <code>except</code>","text":"<p>Wrap config construction so you can gracefully fallback if someone hands you a bad payload. <code>DatePickerConfig</code> re-validates everything in <code>__post_init__</code>, so even if the embedding code misses something you'll get a deterministic exception.</p> <pre><code>from date_range_popover import DatePickerConfig, DateRange, PickerMode\n\ndef build_config(raw: dict) -&gt; DatePickerConfig:\n    range_start, range_end = sanitise_payload(raw.get(\"range\", {}))\n    try:\n        return DatePickerConfig(\n            mode=PickerMode[raw.get(\"mode\", \"DATE\").upper()],\n            initial_range=DateRange(start_date=range_start, end_date=range_end),\n            min_date=sanitise_anchor(raw.get(\"min\")),\n            max_date=sanitise_anchor(raw.get(\"max\")),\n            width=int(raw.get(\"width\", 302)),\n            height=int(raw.get(\"height\", 580)),\n        )\n    except (ValueError, KeyError, Exception) as exc:\n        # Map to your own error reporting; fall back to safe defaults.\n        raise RuntimeError(\"Invalid picker configuration\") from exc\n</code></pre>"},{"location":"embedding/#4-handle-runtime-validation-failures","title":"4. Handle runtime validation failures","text":"<p>The picker emits strong types (e.g. <code>DateRange</code> instances) and its state manager clamps selections to the configured bounds. If you still need to double-check at the edge of your system, reuse the validators:</p> <pre><code>def on_range_selected(date_range: DateRange) -&gt; None:\n    start, end = validate_date_range(\n        date_range.start_date,\n        date_range.end_date,\n        field_name=\"range_selected_signal\",\n        allow_partial=False,\n    )\n    persist_selection(start, end)\n</code></pre>"},{"location":"embedding/#5-clean-up-embedded-widgets","title":"5. Clean up embedded widgets","text":"<p>If you dynamically create/destroy popovers, call <code>DateRangePicker.cleanup</code> when you remove them. This stops animations and releases Qt objects so subsequent embeddings start from a clean slate.</p> <pre><code>popover = DateRangePopover(config=build_config(payload))\npopover.destroyed.connect(popover.cleanup)\n</code></pre>"},{"location":"embedding/#6-read-selection-state-via-properties","title":"6. Read selection state via properties","text":"<p>The public API exposes <code>selected_date</code> and <code>selected_range</code> properties (instead of <code>get_*</code> methods). Properties make it trivial to inspect the current state when wiring menus or command handlers:</p> <pre><code>if popover.selected_range.end_date is not None:\n    print(\"Range locked in:\", popover.selected_range)\n</code></pre> <p>Refer back to <code>README.md</code> for high-level usage and the demo under <code>examples/basic_popover_demo.py</code> for a runnable reference implementation.</p>"},{"location":"extending/","title":"Extending the Picker","text":"<p>The library exposes several hooks so you can tailor the picker without forking the codebase.</p>"},{"location":"extending/#custom-themes","title":"Custom Themes","text":"<p>Build a theme from JSON/YAML and pass it to <code>DatePickerConfig</code>:</p> <pre><code>import json\nfrom date_range_popover.styles.theme import theme_from_mapping\n\npayload = json.load(open(\"theme.json\", \"r\", encoding=\"utf-8\"))\ncustom_theme = theme_from_mapping(payload)\n\nconfig = DatePickerConfig(theme=custom_theme)\n</code></pre> <p>For dynamic themes, implement the <code>ThemeProvider</code> protocol:</p> <pre><code>from dataclasses import dataclass\nfrom date_range_popover.styles.theme import Theme, ThemeProvider\n\n@dataclass\nclass FileThemeProvider(ThemeProvider):\n    path: str\n\n    def build_theme(self) -&gt; Theme:\n        return theme_from_mapping(json.load(open(self.path, \"r\", encoding=\"utf-8\")))\n\nregistry = StyleRegistry(theme=FileThemeProvider(\"dark.json\"))\n</code></pre>"},{"location":"extending/#style-variants","title":"Style Variants","text":"<p><code>StyleRegistry</code> exposes <code>register_button_style</code>, <code>register_calendar_style</code>, and <code>register_input_style</code> so you can inject additional presets at runtime:</p> <pre><code>registry = StyleRegistry()\nregistry.register_button_style(\"danger\", ButtonStyleConfig(...))\nstyle_manager = StyleManager(registry)\nstyle_manager.apply_basic_button(button, variant=\"danger\")\n</code></pre>"},{"location":"extending/#selection-callbacks","title":"Selection Callbacks","text":"<p>Qt signals remain the primary integration point, but you can also register Python callables that receive <code>SelectionSnapshot</code> objects:</p> <pre><code>from date_range_popover.types.selection import SelectionSnapshot\n\ndef log_selection(snapshot: SelectionSnapshot) -&gt; None:\n    print(\"Mode:\", snapshot.mode.name, \"Range:\", snapshot.selected_range)\n\npicker.register_selection_callback(log_selection)\n</code></pre> <p>Callbacks fire synchronously on the Qt GUI thread, so keep handlers lightweight. Unregister them with <code>deregister_selection_callback</code>.</p>"},{"location":"extending/#future-hooks","title":"Future Hooks","text":"<p>The architecture keeps state management Qt-free, which enables future extension points such as:</p> <ul> <li>Swapping calendar renderers while reusing the state manager.</li> <li>Plugging in alternative animation strategies.</li> <li>Serialising themes to/from remote sources.</li> </ul> <p>File an issue if you need a specific hook; promoting it to the supported surface is usually easier than maintaining a fork.</p>"},{"location":"roadmap/","title":"Roadmap &amp; Design Notes","text":"<p>This page captures upcoming ideas, open questions, and constraints that guide the evolution of <code>date_range_popover</code>. It is aspirational\u2014items ship when they have owners.</p>"},{"location":"roadmap/#near-term","title":"Near-Term","text":"<ul> <li>Keyboard navigation &amp; accessibility: expose a11y roles on calendar cells,   add arrow-key navigation, and document focus order.</li> <li>Time-aware mode: extend <code>PickerMode</code> with a time-inclusive variant so   range selection can optionally require start/end times.</li> <li>Theme import/export: allow serialising palettes/layouts to JSON/YAML and   add CLI helpers for generating starter themes.</li> <li>More tests: add Qt screenshot regression tests for high-DPI and RTL   layouts, plus fuzzing for configuration validators.</li> </ul>"},{"location":"roadmap/#medium-term","title":"Medium-Term","text":"<ul> <li>Multiple calendar systems: abstract <code>QDate</code> usage so alternate calendars   (ISO week, fiscal calendars, etc.) can plug in.</li> <li>Animation strategy injection: swap the slide indicator animation with   easing curves or disabled animations for accessibility.</li> <li>State-machine visualiser: ship a developer overlay that shows the current   <code>DatePickerState</code> to simplify debugging embedder issues.</li> <li>Plugin registry: document a convention for discovering theme providers and   selection callbacks via entry points (useful for larger apps).</li> </ul>"},{"location":"roadmap/#long-term-research","title":"Long-Term / Research","text":"<ul> <li>Cross-toolkit frontends: leverage the pure <code>core/state_logic</code> module to   drive frontends in other UI frameworks (Tkinter, React via Pyodide, etc.).</li> <li>Internationalisation: integrate Qt's translation system so labels/month   names come from <code>.qm</code> files rather than hard-coded strings.</li> <li>Async state coordination: explore asyncio-friendly state managers so the   picker can live inside hybrid desktop/web runtimes.</li> </ul>"},{"location":"roadmap/#not-planned-yet","title":"Not Planned (Yet)","text":"<ul> <li>Building a scheduling/timeline UI (this component stays focused on popovers).</li> <li>Supporting legacy Python versions (&lt;3.10).</li> <li>Shipping compiled resources; assets remain as SVGs for now.</li> </ul> <p>Have an idea that's not listed? Open an issue so we can capture it here.</p>"},{"location":"api/public_api/","title":"Public API Surface","text":"<p>The objects documented in this file represent the supported, stable surface area of <code>date_range_popover</code>. Everything else (managers, widgets, coordinators, validators, etc.) is considered internal and can change without notice. Breaking changes to the sections below follow semantic versioning once the package reaches <code>v1.0.0</code>.</p>"},{"location":"api/public_api/#stability-contract","title":"Stability Contract","text":"<ul> <li>Import only from the package root (<code>date_range_popover</code>) or the modules listed   here.</li> <li>Signals, methods, and properties that are not documented should be treated as   internal helpers.</li> <li>All guarantees apply to releases <code>&gt;= 1.0.0</code>. Pre-release builds may change   without deprecation.</li> </ul>"},{"location":"api/public_api/#daterangepopover-daterangepicker","title":"<code>DateRangePopover</code> / <code>DateRangePicker</code>","text":"<ul> <li>Location: <code>from date_range_popover import DateRangePopover, DateRangePicker</code></li> <li>Purpose: Turn-key widgets that expose a minimal embedding surface.</li> <li>Stable members:</li> <li>Properties: <code>selected_date</code>, <code>selected_range</code></li> <li>Methods: <code>set_mode(mode: PickerMode)</code>, <code>reset()</code>, <code>cleanup()</code></li> <li>Qt signals: <code>date_selected(QDate)</code>, <code>range_selected(DateRange)</code>,     <code>cancelled()</code></li> <li>Guarantees:</li> <li><code>selected_date</code> returns an invalid <code>QDate</code> when no single-date selection     exists; otherwise it is clamped to <code>[min_date, max_date]</code>.</li> <li><code>selected_range</code> always has <code>start &lt;= end</code> when both endpoints are present.</li> <li>Signals emit on the Qt GUI thread in the following order:<ol> <li><code>date_selected</code> / <code>range_selected</code></li> <li><code>cancelled</code> (for dismissals)</li> </ol> </li> <li><code>reset()</code> restores the initial configuration without creating a new widget.</li> <li>Methods must be invoked on the Qt GUI thread.</li> </ul>"},{"location":"api/public_api/#datepickerconfig","title":"<code>DatePickerConfig</code>","text":"<ul> <li>Location: <code>from date_range_popover import DatePickerConfig</code></li> <li>Purpose: Validated configuration object consumed by the picker widgets.</li> <li>Stable fields:</li> <li>Layout: <code>width</code>, <code>height</code>, <code>theme</code></li> <li>Selection defaults: <code>initial_date</code>, <code>initial_range</code>, <code>mode</code></li> <li>Bounds: <code>min_date</code>, <code>max_date</code></li> <li>Time controls: <code>time_step_minutes</code></li> <li>Guarantees:</li> <li><code>max_date</code> defaults to <code>QDate.currentDate()</code> when omitted.</li> <li><code>initial_range</code> and <code>initial_date</code> are clamped to <code>[min_date, max_date]</code>.</li> <li>Instantiating with invalid values raises <code>InvalidConfigurationError</code>.</li> </ul>"},{"location":"api/public_api/#daterange","title":"<code>DateRange</code>","text":"<ul> <li>Location: <code>from date_range_popover import DateRange</code></li> <li>Purpose: Immutable container used by signals and configs.</li> <li>Stable attributes: <code>start_date</code>, <code>end_date</code>, <code>start_time</code>, <code>end_time</code></li> <li>Guarantees:</li> <li>When both endpoints exist, <code>start_date &lt;= end_date</code>.</li> <li>Time values are either both valid <code>QTime</code> instances or <code>None</code>.</li> <li>Instances are safe to cache; they never return references to internal state.</li> </ul>"},{"location":"api/public_api/#pickermode","title":"<code>PickerMode</code>","text":"<ul> <li>Location: <code>from date_range_popover import PickerMode</code></li> <li>Values: <code>PickerMode.DATE</code>, <code>PickerMode.CUSTOM_RANGE</code></li> <li>Guarantees: Additional modes may be added in minor releases, but existing   enum values will not change or be removed without deprecation.</li> </ul>"},{"location":"api/public_api/#behavior-guarantees","title":"Behavior Guarantees","text":"<ul> <li><code>range_selected</code> always emits a fully normalized <code>DateRange</code> with defensive   copies of <code>QDate</code> objects.</li> <li>The state manager clamps every selection to the configured bounds. Invalid   inputs raise <code>InvalidDateError</code>.</li> <li><code>DateRangePopover</code> never mutates <code>DatePickerConfig</code> instances passed to the   constructor; treat configs as immutable.</li> <li>The library does not spawn threads; all callbacks and signals fire on the Qt   GUI thread.</li> </ul>"},{"location":"api/public_api/#non-guaranteed-internal-modules","title":"Non-Guaranteed / Internal Modules","text":"<p>The following areas are internal and subject to change between releases:</p> <ul> <li><code>date_range_popover.components.*</code></li> <li><code>date_range_popover.managers.*</code></li> <li><code>date_range_popover.utils.*</code></li> <li><code>date_range_popover.styles.*</code></li> <li><code>date_range_popover.validation.*</code></li> </ul> <p>Rely on them only if you are prepared to vendor or fork the library.</p>"},{"location":"api/reference/","title":"Python API Reference","text":""},{"location":"api/reference/#date_range_popover.DatePickerConfig","title":"<code>DatePickerConfig</code>  <code>dataclass</code>","text":"<p>Canonical configuration object consumed by :class:<code>DateRangePicker</code>.</p> <p>The dataclass performs defensive sanitisation in <code>__post_init__</code> so embedding contexts can accept partially trusted input (for example, values entered in another widget) and still end up with a predictable picker. All numeric dimensions are clamped via :func:<code>validate_dimension</code>, all dates flow through :func:<code>validate_qdate</code>, and ranges are validated by :func:<code>validate_date_range</code>.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Fixed window width in pixels.</p> <code>window_min_width</code> <code>height</code> <code>int</code> <p>Fixed window height in <code>DATE</code> mode.</p> <code>window_min_height</code> <code>theme</code> <code>Theme</code> <p>Theme object containing palette and layout tokens.</p> <code>Theme()</code> <code>initial_date</code> <code>QDate | None</code> <p>Single-date default selection.</p> <code>None</code> <code>initial_range</code> <code>DateRange | None</code> <p>Pre-selected range that overrides <code>initial_date</code>.</p> <code>None</code> <code>mode</code> <code>PickerMode</code> <p>Initial :class:<code>PickerMode</code> (<code>DATE</code> or <code>CUSTOM_RANGE</code>).</p> <code>DATE</code> <code>min_date</code> <code>QDate | None</code> <p>Absolute lower bound for selection/navigation.</p> <code>None</code> <code>max_date</code> <code>QDate | None</code> <p>Absolute upper bound for selection/navigation. Defaults to <code>QDate.currentDate()</code> when omitted to prevent future selections.</p> <code>None</code> <code>time_step_minutes</code> <code>int</code> <p>Step interval for the time selector component.</p> <code>15</code> <p>Raises:</p> Type Description <code>InvalidConfigurationError</code> <p>For any inconsistent value (dimensions out of bounds, <code>min_date &gt; max_date</code>, invalid <code>Theme</code> instances, etc.).</p> Example <p>from PyQt6.QtCore import QDate DatePickerConfig( ...     mode=PickerMode.CUSTOM_RANGE, ...     min_date=QDate(2023, 1, 1), ...     max_date=QDate(2024, 12, 31), ... )</p>"},{"location":"api/reference/#date_range_popover.DatePickerConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Clamp and validate configuration values.</p> <p>Host applications frequently build <code>DatePickerConfig</code> instances from external inputs (API payloads, settings files, etc.). This lifecycle hook ensures all derived values are deterministic before the widget reads them, which significantly reduces the amount of manual sanitisation embedding contexts need to write.</p>"},{"location":"api/reference/#date_range_popover.DateRange","title":"<code>DateRange</code>  <code>dataclass</code>","text":"<p>Immutable date/time container shared across the public API.</p> <p>The dataclass validates its inputs eagerly so host applications can rely on a fully normalized range when they receive it via picker signals. Dates are sanitised with :func:<code>date_range_popover.validation.validate_date_range</code> while time values are checked for <code>QTime.isValid</code>. <code>None</code> values are preserved so callers can intentionally pass open ranges.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>QDate | None</code> <p>Inclusive start of the range (<code>None</code> for an open range).</p> <code>None</code> <code>end_date</code> <code>QDate | None</code> <p>Inclusive end of the range (<code>None</code> for an open range).</p> <code>None</code> <code>start_time</code> <code>QTime | None</code> <p>Optional time paired with <code>start_date</code>.</p> <code>None</code> <code>end_time</code> <code>QTime | None</code> <p>Optional time paired with <code>end_date</code>.</p> <code>None</code> <p>Raises:</p> Type Description <code>InvalidConfigurationError</code> <p>If any <code>QDate</code> or <code>QTime</code> value is invalid or if <code>start_date</code> is after <code>end_date</code>.</p> Example <p>from PyQt6.QtCore import QDate DateRange( ...     start_date=QDate(2024, 1, 1), ...     end_date=QDate(2024, 1, 10), ... )</p>"},{"location":"api/reference/#date_range_popover.DateRange.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Normalise and validate date/time fields immediately after creation.</p>"},{"location":"api/reference/#date_range_popover.DateRangePicker","title":"<code>DateRangePicker</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>High-level facade for constructing and embedding the popover.</p> <p>The widget exposes a small surface area focused on things host applications care about: reacting to user selections (via Qt signals), reading the current selection, switching between picker modes, and resetting/cleaning up resources. Everything else\u2014layout, component wiring, state transitions\u2014is encapsulated so the embedding code stays simple.</p> Example <p>picker = DateRangePicker(DatePickerConfig(mode=PickerMode.DATE)) picker.date_selected.connect(lambda d: print(d.toString(\"yyyy-MM-dd\"))) picker.show()</p>"},{"location":"api/reference/#date_range_popover.DateRangePicker--signals","title":"Signals","text":"<p>date_selected(QDate)     Emitted when a single date is confirmed. An invalid <code>QDate</code> indicates     that no date is currently selected. range_selected(DateRange)     Emitted when both ends of the range are locked in. cancelled()     Emitted when the user dismisses or cancels the popover.</p>"},{"location":"api/reference/#date_range_popover.DateRangePicker.selected_date","title":"<code>selected_date</code>  <code>property</code>","text":"<p>Currently selected single date.</p> <p>Returns:</p> Type Description <code>QDate</code> <p>A defensive <code>QDate</code> copy representing the active single-date</p> <code>QDate</code> <p>selection. The value is invalid (<code>QDate()</code>) when no single date is</p> <code>QDate</code> <p>locked in.</p> Guarantees <ul> <li>When valid, the date always respects <code>config.min_date</code> /   <code>config.max_date</code>.</li> <li>The returned object is never shared with internal state.</li> </ul>"},{"location":"api/reference/#date_range_popover.DateRangePicker.selected_range","title":"<code>selected_range</code>  <code>property</code>","text":"<p>Currently selected range (may be partial).</p> <p>Returns:</p> Type Description <code>DateRange</code> <p>class:<code>DateRange</code>: a defensive copy with the best-known endpoints.</p> <code>DateRange</code> <p>Missing endpoints remain <code>None</code> so callers can differentiate</p> <code>DateRange</code> <p>between partial and complete selections.</p> Guarantees <ul> <li>When present, endpoints always satisfy <code>start &lt;= end</code>.</li> <li>Every endpoint is clamped to <code>[min_date, max_date]</code>.</li> </ul>"},{"location":"api/reference/#date_range_popover.DateRangePicker.__init__","title":"<code>__init__(config=None, parent=None)</code>","text":"<p>Build a picker instance using the provided configuration.</p> <p>The constructor clones all configuration values and initialises the internal managers immediately, so callers should treat the config object as immutable after passing it in.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>DatePickerConfig | None</code> <p>Optional :class:<code>DatePickerConfig</code>. Defaults to a new instance when omitted.</p> <code>None</code> <code>parent</code> <code>QWidget | None</code> <p>Optional widget parent for lifetime management.</p> <code>None</code> <p>Raises:</p> Type Description <code>InvalidConfigurationError</code> <p>Propagated when <code>config</code> contains invalid values (for example, <code>min_date &gt; max_date</code>).</p>"},{"location":"api/reference/#date_range_popover.DateRangePicker.cleanup","title":"<code>cleanup()</code>","text":"<p>Release long-lived objects and stop active animations.</p> <p>Call this during application teardown or when removing the widget from a complex embedding scenario to make sure timers/animations are cleaned up.</p> Notes <p>The widget becomes unusable after <code>cleanup</code>; create a new instance if you need to re-mount the UI.</p>"},{"location":"api/reference/#date_range_popover.DateRangePicker.deregister_selection_callback","title":"<code>deregister_selection_callback(callback)</code>","text":"<p>Remove a previously registered callback.</p> <p>Calling this method with an unknown callback is a no-op.</p>"},{"location":"api/reference/#date_range_popover.DateRangePicker.register_selection_callback","title":"<code>register_selection_callback(callback)</code>","text":"<p>Register a Python callback that mirrors the Qt selection signals.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>SelectionCallback</code> <p>Callable that receives a :class:<code>SelectionSnapshot</code>.</p> required Notes <p>Callbacks are invoked synchronously on the Qt GUI thread. They are in addition to (not instead of) the Qt signals, which remain the canonical integration surface for Qt consumers.</p>"},{"location":"api/reference/#date_range_popover.DateRangePicker.reset","title":"<code>reset()</code>","text":"<p>Reset the picker state to match the initial configuration.</p> <p>This method clears animations, re-applies selection defaults, and ensures the coordinator redraws UI components.</p> Notes <p>Safe to call any time the host wants to discard in-progress user input. Must run on the Qt GUI thread.</p>"},{"location":"api/reference/#date_range_popover.DateRangePicker.set_mode","title":"<code>set_mode(mode)</code>","text":"<p>Switch the picker to the provided :class:<code>PickerMode</code>.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>PickerMode</code> <p><code>PickerMode.DATE</code> or <code>PickerMode.CUSTOM_RANGE</code>.</p> required Notes <p>Must be invoked from the Qt GUI thread because it drives widget mutations and animations.</p>"},{"location":"api/reference/#date_range_popover.DateRangePopover","title":"<code>DateRangePopover</code>","text":"<p>               Bases: <code>DateRangePicker</code></p> <p>Turn-key widget that wraps :class:<code>DateRangePicker</code> for embedding.</p> <p>Importing :class:<code>DateRangePopover</code> keeps application code terse; it exposes the same public API as :class:<code>DateRangePicker</code> but ships with a default configuration. That makes it handy for quick experiments and demos. Pass a pre-sanitised :class:<code>DatePickerConfig</code> so constraints (min/max dates, layout bounds, themes) stay explicit at construction time.</p> Example <p>popover = DateRangePopover() popover.range_selected.connect(lambda r: print(r.start_date, r.end_date)) popover.show()</p>"},{"location":"api/reference/#date_range_popover.DateRangePopover.__init__","title":"<code>__init__(config=None, parent=None)</code>","text":"<p>Build the popover using the provided configuration and optional parent.</p> <p>:param config: Optional :class:<code>DatePickerConfig</code>. Falls back to     defaults. :param parent: Parent widget responsible for lifetime management.</p>"}]}